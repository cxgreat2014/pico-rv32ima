# é¡¹ç›®æ¶æ„

æœ¬æ–‡æ¡£è¯¦ç»†ä»‹ç» pico-rv32ima é¡¹ç›®çš„æŠ€æœ¯æ¶æ„ã€æ ¸å¿ƒç»„ä»¶å’Œå®ç°åŸç†ã€‚

## ğŸ—ï¸ æ•´ä½“æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Raspberry Pi Pico                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Core 0              â”‚  Core 1                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Console Task    â”‚ â”‚  â”‚ RISC-V Emulator                 â”‚ â”‚
â”‚  â”‚ - USB CDC       â”‚ â”‚  â”‚ - mini-rv32ima core             â”‚ â”‚
â”‚  â”‚ - UART          â”‚ â”‚  â”‚ - Linux kernel execution        â”‚ â”‚
â”‚  â”‚ - VGA Terminal  â”‚ â”‚  â”‚ - System calls handling         â”‚ â”‚
â”‚  â”‚ - PS/2 Keyboard â”‚ â”‚  â”‚ - Memory management             â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    Hardware Abstraction                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚ PSRAM       â”‚ â”‚ SD Card     â”‚ â”‚ VGA/PS2     â”‚           â”‚
â”‚  â”‚ (SPI)       â”‚ â”‚ (SPI)       â”‚ â”‚ (GPIO/PIO)  â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ§  æ ¸å¿ƒç»„ä»¶

### 1. RISC-V æ¨¡æ‹Ÿå™¨æ ¸å¿ƒ

åŸºäº CNLohr çš„ mini-rv32ima å®ç°ï¼Œæ”¯æŒï¼š

- **æŒ‡ä»¤é›†**: RV32IMA (32ä½åŸºç¡€æŒ‡ä»¤ + ä¹˜æ³•/é™¤æ³• + åŸå­æ“ä½œ)
- **ç‰¹æƒçº§**: Machine Mode å’Œ User Mode
- **CSR**: æ§åˆ¶å’ŒçŠ¶æ€å¯„å­˜å™¨æ”¯æŒ
- **ä¸­æ–­**: å®šæ—¶å™¨ä¸­æ–­å’Œå¤–éƒ¨ä¸­æ–­
- **ç³»ç»Ÿè°ƒç”¨**: Linux ç³»ç»Ÿè°ƒç”¨æ¨¡æ‹Ÿ

#### å…³é”®ç‰¹æ€§
```c
// æ ¸å¿ƒé…ç½®
#define MINI_RV32_RAM_SIZE (EMULATOR_RAM_MB * 1024 * 1024)
#define MINIRV32_RAM_IMAGE_OFFSET 0x80000000

// æ‰§è¡Œå¾ªç¯
int MiniRV32IMAStep(struct MiniRV32IMAState *state, 
                    uint8_t *ram, uint32_t ram_size, 
                    uint64_t elapsed_us, int count);
```

### 2. å†…å­˜ç®¡ç†ç³»ç»Ÿ

#### PSRAM æ¥å£
- **å®¹é‡**: 8MB æˆ– 16MB (1-2 ç‰‡ PSRAM)
- **æ¥å£**: SPI é«˜é€Ÿè®¿é—®
- **ç¼“å­˜**: 128KB äºŒè·¯ç»„ç›¸è”ç¼“å­˜

```c
// PSRAM è®¿é—®æ¥å£
void psram_access(uint32_t addr, size_t size, bool write, void *bufP);

// ç¼“å­˜ç³»ç»Ÿ
typedef struct {
    uint32_t tag;
    uint8_t data[CACHE_LINE_SIZE];
    bool valid;
    bool dirty;
} cache_line_t;
```

#### å†…å­˜æ˜ å°„
```
0x80000000 - 0x80000000 + RAM_SIZE : ä¸»å†…å­˜ (PSRAM)
0x10000000 - 0x10000FFF             : UART MMIO
0x02000000 - 0x02000FFF             : CLINT (å®šæ—¶å™¨)
0x0C000000 - 0x0CFFFFFF             : PLIC (ä¸­æ–­æ§åˆ¶å™¨)
```

### 3. å­˜å‚¨ç³»ç»Ÿ

#### SD å¡æ¥å£
- **åè®®**: SPI æ¨¡å¼
- **æ–‡ä»¶ç³»ç»Ÿ**: FAT16/FAT32 (PetitFatFS)
- **æ–‡ä»¶**: IMAGE (å†…æ ¸), ROOTFS (æ ¹æ–‡ä»¶ç³»ç»Ÿ)

```c
// SD å¡æ“ä½œ
FRESULT pf_mount(FATFS *fs);
FRESULT pf_open(const char *path);
FRESULT pf_read(void *buff, UINT btr, UINT *br);
```

### 4. æ˜¾ç¤ºå’Œè¾“å…¥ç³»ç»Ÿ

#### VGA æ–‡æœ¬æ˜¾ç¤º
- **åˆ†è¾¨ç‡**: 640x480 @ 60Hz
- **æ–‡æœ¬æ¨¡å¼**: 80x30 å­—ç¬¦
- **é¢œè‰²**: 16 è‰²å‰æ™¯/èƒŒæ™¯
- **å®ç°**: PIO + DMA

```c
// VGA æ ¸å¿ƒç»“æ„
char termBuf[TERM_HEIGHT][TERM_WIDTH];
uint8_t fgColBuf[TERM_HEIGHT][TERM_WIDTH];
uint8_t bgColBuf[TERM_HEIGHT][TERM_WIDTH];
```

#### PS/2 é”®ç›˜
- **åè®®**: PS/2 æ ‡å‡†åè®®
- **å®ç°**: GPIO ä¸­æ–­ + çŠ¶æ€æœº
- **ç¼“å†²**: ç¯å½¢ç¼“å†²åŒº

### 5. æ§åˆ¶å°ç³»ç»Ÿ

æ”¯æŒå¤šç§æ§åˆ¶å°åŒæ—¶å·¥ä½œï¼š

```c
// æ§åˆ¶å°ç±»å‹
#define CONSOLE_CDC  1  // USB CDC
#define CONSOLE_VGA  1  // VGA æ–‡æœ¬
#define CONSOLE_UART 0  // UART ä¸²å£

// ç»Ÿä¸€æ¥å£
void console_putc(char c);
void console_printf(const char *format, ...);
```

## âš™ï¸ ç³»ç»Ÿå¯åŠ¨æµç¨‹

### 1. ç¡¬ä»¶åˆå§‹åŒ–
```c
int main() {
    // è¶…é¢‘é…ç½®
    vreg_set_voltage(RP2040_OVERVOLT);
    set_sys_clock_khz(RP2040_CPU_FREQ, true);
    
    // æ§åˆ¶å°åˆå§‹åŒ–
    console_init();
    
    // åŒæ ¸å¯åŠ¨
    multicore_launch_core1(core1_entry);
}
```

### 2. ç³»ç»Ÿç»„ä»¶å¯åŠ¨
```c
void core1_entry() {
    // ç­‰å¾…ç”¨æˆ·æŒ‰é”®
    wait_button();
    
    // PSRAM åˆå§‹åŒ–
    psram_init();
    
    // SD å¡æŒ‚è½½
    pf_mount(&fatfs);
    
    // å¯åŠ¨ RISC-V æ¨¡æ‹Ÿå™¨
    riscv_emu();
}
```

### 3. Linux å†…æ ¸åŠ è½½
```c
int riscv_emu() {
    // æ‰“å¼€å†…æ ¸æ–‡ä»¶
    pf_open(KERNEL_FILENAME);
    
    // åŠ è½½åˆ° PSRAM
    while (pf_read(blk_buf, sizeof(blk_buf), &br)) {
        psram_access(addr, br, true, blk_buf);
        addr += br;
    }
    
    // è®¾ç½®å¯åŠ¨å‚æ•°
    core.regs[10] = 0x00;  // hart ID
    core.regs[11] = dtb_ptr; // device tree
    core.pc = MINIRV32_RAM_IMAGE_OFFSET;
    
    // å¼€å§‹æ‰§è¡Œ
    MiniRV32IMAStep(&core, NULL, 0, elapsedUs, instrs_per_flip);
}
```

## ğŸ”„ æ‰§è¡Œæ¨¡å‹

### åŒæ ¸åˆ†å·¥
- **Core 0**: å¤„ç† I/O å’Œæ§åˆ¶å°ä»»åŠ¡
- **Core 1**: è¿è¡Œ RISC-V æ¨¡æ‹Ÿå™¨

### æ—¶é—´ç®¡ç†
```c
// æ—¶é—´åŒæ­¥
uint64_t GetTimeMicroseconds();
uint64_t elapsedUs = (rt - lastTime) * time_divisor;

// æŒ‡ä»¤æ‰§è¡Œæ§åˆ¶
int instrs_per_flip = 1024;
MiniRV32IMAStep(&core, NULL, 0, elapsedUs, instrs_per_flip);
```

### ä¸­æ–­å¤„ç†
```c
// å®šæ—¶å™¨ä¸­æ–­
if ((CSR(mip) & (1<<7)) && (CSR(mie) & (1<<7)) && (CSR(mstatus) & 0x8)) {
    trap = 0x80000007;  // å®šæ—¶å™¨ä¸­æ–­
}

// ç³»ç»Ÿè°ƒç”¨å¤„ç†
case 0x7777: return EMU_REBOOT;   // é‡å¯
case 0x5555: return EMU_POWEROFF; // å…³æœº
```

## ğŸš€ æ€§èƒ½ä¼˜åŒ–

### 1. ç¼“å­˜ç³»ç»Ÿ
- **ç±»å‹**: äºŒè·¯ç»„ç›¸è”
- **å¤§å°**: 128KB
- **ç­–ç•¥**: LRU æ›¿æ¢

### 2. SPI ä¼˜åŒ–
- **PSRAM**: 55MHz æ—¶é’Ÿé¢‘ç‡
- **DMA**: ç”¨äºå¤§å—æ•°æ®ä¼ è¾“
- **æ‰¹å¤„ç†**: å‡å°‘ SPI äº‹åŠ¡å¼€é”€

### 3. æŒ‡ä»¤ä¼˜åŒ–
- **æ‰¹é‡æ‰§è¡Œ**: æ¯æ¬¡æ‰§è¡Œå¤šæ¡æŒ‡ä»¤
- **åˆ†æ”¯é¢„æµ‹**: ç®€å•çš„åˆ†æ”¯ä¼˜åŒ–
- **å†…å­˜é¢„å–**: ç¼“å­˜å‹å¥½çš„è®¿é—®æ¨¡å¼

## ğŸ”§ æ‰©å±•æ¥å£

### MMIO å¤„ç†
```c
// æ§åˆ¶å¯„å­˜å™¨è®¿é—®
static uint32_t HandleControlStore(uint32_t addy, uint32_t val);
static uint32_t HandleControlLoad(uint32_t addy);

// UART 8250 æ¨¡æ‹Ÿ
if (addy == 0x10000000) console_putc(val);      // æ•°æ®å¯„å­˜å™¨
if (addy == 0x10000005) return 0x60 | IsKBHit(); // çŠ¶æ€å¯„å­˜å™¨
```

### è®¾å¤‡æ ‘æ”¯æŒ
```c
// è®¾å¤‡æ ‘æŒ‡é’ˆä¼ é€’
core.regs[11] = dtb_ptr ? (dtb_ptr + MINIRV32_RAM_IMAGE_OFFSET) : 0;
```

## ğŸ“Š ç³»ç»Ÿé™åˆ¶

### ç¡¬ä»¶é™åˆ¶
- **å†…å­˜**: æœ€å¤§ 16MB PSRAM
- **å­˜å‚¨**: SD å¡å®¹é‡é™åˆ¶
- **CPU**: RP2040/RP2350 æ€§èƒ½é™åˆ¶

### è½¯ä»¶é™åˆ¶
- **MMU**: æ— å†…å­˜ç®¡ç†å•å…ƒ
- **æµ®ç‚¹**: è½¯ä»¶æµ®ç‚¹è¿ç®—
- **å¤šæ ¸**: Linux è¿è¡Œåœ¨å•æ ¸æ¨¡æ‹Ÿå™¨ä¸Š

## ğŸ” è°ƒè¯•å’Œç›‘æ§

### æ€§èƒ½ç›‘æ§
```c
// å‘¨æœŸè®¡æ•°
uint64_t cycleh, cyclel;
console_printf("Cycles: 0x%08x%08x\n", core.cycleh, core.cyclel);

// æŒ‡ä»¤è®¡æ•°
long long instct;
```

### é”™è¯¯å¤„ç†
```c
// å¼‚å¸¸ç±»å‹
case 1: // æŒ‡ä»¤è®¿é—®å¼‚å¸¸
case 2: // éæ³•æŒ‡ä»¤
case 3: // æ–­ç‚¹
case 4: // åŠ è½½åœ°å€ä¸å¯¹é½
case 5: // åŠ è½½è®¿é—®å¼‚å¸¸
```

è¿™ä¸ªæ¶æ„è®¾è®¡å®ç°äº†åœ¨èµ„æºå—é™çš„å¾®æ§åˆ¶å™¨ä¸Šè¿è¡Œå®Œæ•´ Linux ç³»ç»Ÿçš„ç›®æ ‡ï¼Œé€šè¿‡ç²¾å¿ƒçš„ç»„ä»¶è®¾è®¡å’Œä¼˜åŒ–ç­–ç•¥ï¼Œè¾¾åˆ°äº†è‰¯å¥½çš„æ€§èƒ½å’Œç¨³å®šæ€§ã€‚
